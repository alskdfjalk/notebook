<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>docker</title>
<!-- 2016-02-23 Tue 18:17 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="CarlJohn" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css"
    href="/Users/cj/.emacs.d/org/css/htmlize.css"/>

<link rel="stylesheet" type="text/css"
    href="/Users/cj/.emacs.d/org/css/bigblow.css"/>

<link rel="stylesheet" type="text/css"
    href="/Users/cj/.emacs.d/org/css/hideshow.css"/>


<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery-1.11.0.min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery-ui-1.10.2.min.js"></script>


<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.localscroll-min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.scrollTo-1.4.3.1-min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.zclip.min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/bigblow.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/hideshow.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">docker</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. The Docker user guide</a>
<ul>
<li><a href="#sec-1-1">1.1. 目的</a></li>
<li><a href="#sec-1-2">1.2. Docker Hub</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. 地址</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. Docker 应用"Hello world"</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. 在容器中输出hello world</a></li>
<li><a href="#sec-1-3-2">1.3.2. 交互式的容器</a></li>
<li><a href="#sec-1-3-3">1.3.3. 容器成为守护进程</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Docker 运行实例</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. 启动一个实例</a></li>
<li><a href="#sec-1-4-2">1.4.2. 查看状态</a></li>
<li><a href="#sec-1-4-3">1.4.3. 监听在其他端口</a></li>
<li><a href="#sec-1-4-4">1.4.4. 查看网络端口快捷方式</a></li>
<li><a href="#sec-1-4-5">1.4.5. 查看WEB应用日志</a></li>
<li><a href="#sec-1-4-6">1.4.6. 查看WEB应用的进程</a></li>
<li><a href="#sec-1-4-7">1.4.7. 查看docker容器的配置和状态信息</a></li>
<li><a href="#sec-1-4-8">1.4.8. 重启WEB应用容器</a></li>
<li><a href="#sec-1-4-9">1.4.9. 删除容器</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Docker 镜像</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. 公共镜像</a></li>
<li><a href="#sec-1-5-2">1.5.2. 自定义镜像</a></li>
<li><a href="#sec-1-5-3">1.5.3. 镜像标签(tag)</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. Docker 连接容器</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1. 端口映射</a></li>
<li><a href="#sec-1-6-2">1.6.2. 容器连接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. 原理（实现方式）</a>
<ul>
<li><a href="#sec-2-1">2.1. 目的</a></li>
<li><a href="#sec-2-2">2.2. namespace</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1. 资源隔离标志位(20多种CLONE<sub>*</sub>)</a></li>
<li><a href="#sec-2-2-2">2.2.2. /proc/[pid]/ns 目录</a></li>
<li><a href="#sec-2-2-3">2.2.3. namespace的四种API</a></li>
<li><a href="#sec-2-2-4">2.2.4. UTS(UNIX Time-sharing System) namespace</a></li>
<li><a href="#sec-2-2-5">2.2.5. IPC(Inter-Process Communication) namespace</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. Docker 常用选项</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The Docker user guide</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 目的</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>docker中运行你的应用程序
</li>
<li>运行你自己的容器
</li>
<li>创建docker镜像
</li>
<li>分享docker镜像
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Docker Hub</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 地址</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
<a href="https://hub.docker.com/">https://hub.docker.com/</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Docker 应用"Hello world"</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 在容器中输出hello world</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run centos:6 echo 'hello world'
hello world
</pre>
</div>
<ol class="org-ol">
<li>命令解释
</li>
<li>docker run 组合会运行容器
</li>
<li>centos:6 指定镜像版本（如果本地没有找到镜像，则从docker.com查找
</li>
<li>容器中执行的命令
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 交互式的容器</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -t -i centos:6 /bin/bash
root@af8bae53bdd3:/#
</pre>
</div>
<ol class="org-ol">
<li>选项解释：

<p>
-t 表示在新容器内指定一个伪终端或终端
</p>

<p>
-i 表示允许对容器内的(STDIN)进行交互
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> 容器成为守护进程</h4>
<div class="outline-text-4" id="text-1-3-3">
<ol class="org-ol">
<li>启动进程
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -d centos:6 bash -c "while true; do echo hello world; done"
1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147(容器ID（Container ID)
</pre>
</div>
</li>
<li>容器进程查看
<div class="org-src-container">

<pre class="src src-shell">sudo docker ps
CONTAINER ID  IMAGE         COMMAND            CREATED       STATUS     PORTS   NAMES
7d045853d31b centos:6 "bash -c 'while true;" 7 minutes ago  Up 7 minutes    furious_wozniak
</pre>
</div>
</li>
<li>查看容器内应用的输出
<div class="org-src-container">

<pre class="src src-shell">sudo docker logs furious_wozniak
</pre>
</div>
</li>
<li>关闭容器
<div class="org-src-container">

<pre class="src src-shell">sudo docker stop furious_wozniak
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Docker 运行实例</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> 启动一个实例</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -d -P training/webapp python app.py
</pre>
</div>
<p>
-P 选项通知 Docker 将容器内部使用的网络端口映射到我们使用的主机上
</p>

<p>
本例中指定了training/web 镜像。这个镜像已经包含了简单的Flask web 应用
</p>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> 查看状态</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker ps -l
# 多出一个 0.0.0.0:32768-&gt;5000/tcp
# 5000端口是镜像预定义的端口
# 可以在构建容器时指定默认端口
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> 监听在其他端口</h4>
<div class="outline-text-4" id="text-1-4-3">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -d -p 5000:5000 training/webapp python app.py
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> 查看网络端口快捷方式</h4>
<div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker port xxxxxxxxxx 5000
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> 查看WEB应用日志</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -
10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 -
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6"><span class="section-number-4">1.4.6</span> 查看WEB应用的进程</h4>
<div class="outline-text-4" id="text-1-4-6">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker top xxxxxx_xxx
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-7" class="outline-4">
<h4 id="sec-1-4-7"><span class="section-number-4">1.4.7</span> 查看docker容器的配置和状态信息</h4>
<div class="outline-text-4" id="text-1-4-7">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker inspect xxxxxxx_xxx
</pre>
</div>

<div class="org-src-container">

<pre class="src src-shell">sudo docker inspect -f '{{ .NetworkSettings.IPAddress }}' nostalgic_morse
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-8" class="outline-4">
<h4 id="sec-1-4-8"><span class="section-number-4">1.4.8</span> 重启WEB应用容器</h4>
<div class="outline-text-4" id="text-1-4-8">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker restart xxxxxx_xxx
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-9" class="outline-4">
<h4 id="sec-1-4-9"><span class="section-number-4">1.4.9</span> 删除容器</h4>
<div class="outline-text-4" id="text-1-4-9">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker rm xxxxxx_xxxx
</pre>
</div>

<p>
注意：不能删除正在运行中的容器，必须先stop
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Docker 镜像</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> 公共镜像</h4>
<div class="outline-text-4" id="text-1-5-1">
</div><ol class="org-ol"><li><a id="sec-1-5-1-0-1" name="sec-1-5-1-0-1"></a>在主机上列出镜像列表<br  /><div class="outline-text-6" id="text-1-5-1-0-1">
<p>
列出本地可以使用的镜像
</p>
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker images
</pre>
</div>
</div>
</li>
<li><a id="sec-1-5-1-0-2" name="sec-1-5-1-0-2"></a>获取一个新的镜像<br  /><div class="outline-text-6" id="text-1-5-1-0-2">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker pull centos
</pre>
</div>
</div>
</li>
<li><a id="sec-1-5-1-0-3" name="sec-1-5-1-0-3"></a>搜索镜像<br  /><div class="outline-text-6" id="text-1-5-1-0-3">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker search centos
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> 自定义镜像</h4>
<div class="outline-text-4" id="text-1-5-2">
</div><ol class="org-ol"><li><a id="sec-1-5-2-0-1" name="sec-1-5-2-0-1"></a>更新并且提交更改<br  /><div class="outline-text-6" id="text-1-5-2-0-1">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -t -i training/sinatra /bin/bash
root@0b2616b0e5a8:/#
注意：已创建容器ID 0b2616b0e5a8，需要指定这个ID来提交新的更改
</pre>
</div>

<p>
修改之后提交
</p>

<div class="org-src-container">

<pre class="src src-shell">$ sudo docker commit -m="Added json gem" -a="Kate Smith" 0b2616b0e5a8 ouruser/sinatra:v2
4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</pre>
</div>

<p>
-m 参数来指定提交信息
</p>

<p>
-a 参数来指定提交人
</p>
</div>
</li>
<li><a id="sec-1-5-2-0-2" name="sec-1-5-2-0-2"></a>使用 Dockerfile 构建镜像<br  /><div class="outline-text-6" id="text-1-5-2-0-2">
<ol class="org-ol">
<li>准备路径
<div class="org-src-container">

<pre class="src src-shell">$ cd /tmp
$ mkdir sinatra
$ cd sinatra
$ touch Dockerfile
</pre>
</div>
</li>
<li>编写配置

<p>
在Dockerfile添加如下内容
</p>
<div class="org-src-container">

<pre class="src src-conf"># This is a comment
FROM fedora
MAINTAINER CJ &lt;zhangyafeng097@emao.com&gt;
RUN dnf install emacs -y
</pre>
</div>
</li>
<li>执行打包（构建）
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker build -t lala/sinatra:v5 /tmp/sinatra
</pre>
</div>
</li>

<li>注意

<p>
<i><b>与存储程序驱动无关，镜像不能超过127层。这是一种全局设置，为了是从整体上来优化镜像的大小。</b></i>
</p>
</li>

<li>Dockerfile资料
<a href="https://docs.docker.com/userguide/level1/">https://docs.docker.com/userguide/level1/</a>
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> 镜像标签(tag)</h4>
<div class="outline-text-4" id="text-1-5-3">
</div><ol class="org-ol"><li><a id="sec-1-5-3-0-1" name="sec-1-5-3-0-1"></a>添加标签<br  /><div class="outline-text-6" id="text-1-5-3-0-1">
<div class="org-src-container">

<pre class="src src-shell">$ docker tag 5db5f8471261 ouruser/sinatra:devel
docker tag 需要使用镜像ID，这里是 5db5f8471261，用户名、镜像源和新的标签名。
</pre>
</div>
</div>
</li>
<li><a id="sec-1-5-3-0-2" name="sec-1-5-3-0-2"></a>查看某镜像的标签<br  /><div class="outline-text-6" id="text-1-5-3-0-2">
<div class="org-src-container">

<pre class="src src-shell">$ docker images ouruser/sinatra
REPOSITORY          TAG     IMAGE ID      CREATED        VIRTUAL SIZE
ouruser/sinatra     latest  5db5f8471261  11 hours ago   446.7 MB
ouruser/sinatra     devel   5db5f8471261  11 hours ago   446.7 MB
ouruser/sinatra     v2      5db5f8471261  11 hours ago   446.7 MB
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Docker 连接容器</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> 端口映射</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>指定udp映射
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> 容器连接</h4>
<div class="outline-text-4" id="text-1-6-2">
</div><ol class="org-ol"><li><a id="sec-1-6-2-0-1" name="sec-1-6-2-0-1"></a>概念<br  /><div class="outline-text-6" id="text-1-6-2-0-1">
<p>
端口映射并不是唯一把docker连接到另一个容器的方法。docker有一个连接系统允许将多个容器连接在一起，
共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。
</p>
</div>
</li>
<li><a id="sec-1-6-2-0-2" name="sec-1-6-2-0-2"></a>容器命名<br  /><div class="outline-text-6" id="text-1-6-2-0-2">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d -P --name web training/webapp python app.py
</pre>
</div>
</div>
</li>
<li><a id="sec-1-6-2-0-3" name="sec-1-6-2-0-3"></a>获取容器名字<br  /><div class="outline-text-6" id="text-1-6-2-0-3">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker inspect -f "{{ .Name }}" aed84ee21bde
/web
</pre>
</div>
</div>
</li>
<li><a id="sec-1-6-2-0-4" name="sec-1-6-2-0-4"></a>容器连接<br  /><div class="outline-text-6" id="text-1-6-2-0-4">
<p>
连接允许容器之间可见并且安全地进行通信。使用&#x2013;link创建连接。我们创建一个新容器，这个容器是数据库。
</p>
<ol class="org-ol">
<li>创建一个db容器
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d --name db training/postgres
</pre>
</div>
</li>
<li>创建一个web容器连接db容器
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py
# --link name:alias
</pre>
</div>
</li>
</ol>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 原理（实现方式）</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
了解docker的实现机制会有助于用更合适的方式来使用docker
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> namespace</h3>
<div class="outline-text-3" id="text-2-2">
</div><div id="outline-container-sec-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 资源隔离标志位(20多种CLONE<sub>*</sub>)</h4>
<div class="outline-text-4" id="text-2-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">namespace</th>
<th scope="col" class="left">系统调用参数</th>
<th scope="col" class="left">隔离内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">UTS</td>
<td class="left">CLONE<sub>NEWUTS</sub></td>
<td class="left">主机名与域名</td>
</tr>

<tr>
<td class="left">IPC</td>
<td class="left">CLONE<sub>NEWIPC</sub></td>
<td class="left">信号量、消息队列和共享内存</td>
</tr>

<tr>
<td class="left">PID</td>
<td class="left">CLONE<sub>NEWPID</sub></td>
<td class="left">进程编号</td>
</tr>

<tr>
<td class="left">Network</td>
<td class="left">CLONE<sub>NEWNET</sub></td>
<td class="left">网络设备、网络栈、端口</td>
</tr>

<tr>
<td class="left">Mount</td>
<td class="left">CLONE<sub>NEWNS</sub></td>
<td class="left">挂载点</td>
</tr>

<tr>
<td class="left">User</td>
<td class="left">CLONE<sub>NEWUSER</sub></td>
<td class="left">用户和用户组</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> /proc/[pid]/ns 目录</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
从3.8内核开始，可以在该目录下看到指向不同namespace号的文件如：
</p>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 12:39 ~]$ ls -l /proc/$$/ns
总用量 0
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 net -&gt; net:[4026531957]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 user -&gt; user:[4026531837]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 uts -&gt; uts:[4026531838]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> namespace的四种API</h4>
<div class="outline-text-4" id="text-2-2-3">
</div><ol class="org-ol"><li><a id="sec-2-2-3-1" name="sec-2-2-3-1"></a>clone()<br  /><div class="outline-text-5" id="text-2-2-3-1">
<ol class="org-ol">
<li>通过clone()在创建新进程的同时创建namespace
<div class="org-src-container">

<pre class="src src-c">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);
// child_func 传入子进程运行的程序主函数
// child_stack 传入子进程使用的栈空间
// flags 表示使用哪些CLONE_*标志位，与namespace相关的已列在上表中
// args 用于传入用户参数
</pre>
</div>
</li>
</ol>
</div>
</li>
<li><a id="sec-2-2-3-2" name="sec-2-2-3-2"></a>setns() 加入一个已经存在的namespace<br  /><div class="outline-text-5" id="text-2-2-3-2">
<p>
在 Docker 中，使用 docker exec 在已经运行着的容器中执行一个新的命令，就需要用到该方法。
</p>
<div class="org-src-container">

<pre class="src src-C">int setns(int fd, int nstype);
// 参数 fd 表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录的文件喵舒服。
// 参数 nstype 让调用者可以检查mespace类型是否符合实际要求。参数为 0 时 不检查。
</pre>
</div>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-shell">touch ~/uts
mount --bind /proc/27514/ns/utf ~/uts
</pre>
</div>
<div class="org-src-container">

<pre class="src src-c">fd = open(argv[1], O_RDONLY);
setns(fd, 0);
execvp(argv[2], &amp;argv[2]);
</pre>
</div>
</div>
</li>

<li><a id="sec-2-2-3-3" name="sec-2-2-3-3"></a>unshare()<br  /><div class="outline-text-5" id="text-2-2-3-3">
<p>
同 clone()，但运行在原先的进程上，不需要启动一个新进程。(在Docker中并没有使用这个接口）
</p>
<div class="org-src-container">

<pre class="src src-c">int unshare(int flags);
</pre>
</div>
</div>
</li>

<li><a id="sec-2-2-3-4" name="sec-2-2-3-4"></a>fork()<br  /><div class="outline-text-5" id="text-2-2-3-4">
<p>
就这么点事儿，fork后看返回值来确定自己是否是子进程，然后做不同的操作 - -|||
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-2-4" class="outline-4">
<h4 id="sec-2-2-4"><span class="section-number-4">2.2.4</span> UTS(UNIX Time-sharing System) namespace</h4>
<div class="outline-text-4" id="text-2-2-4">
<p>
提供了主机名和域名的隔离，这样才能在网络上被当作一个独立的节点，而非宿主机上的一个进程。
在Docker中，每个镜像基本都以自身提供的服务名称来命名镜像的hostname，且不会对宿主机产生任何影响，原理就是利用UTS namespace
</p>
<div class="org-src-container">

<pre class="src src-c">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];
char * const child_args[] = {
	"/bin/bash",
	NULL,
};

int child_main(void *args)
{
	printf("在子进程中!\n");
	sethostname("NewNamespace", 12);
	execv(child_args[0], child_args);
	return 1;
}

int main()
{
	printf("程序开始：\n");
	int child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);
	if (0 &gt; child_pid)
		perror("不知到为什么错了");
	waitpid(child_pid, NULL, 0);
	puts("已退出");
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-2-5" class="outline-4">
<h4 id="sec-2-2-5"><span class="section-number-4">2.2.5</span> IPC(Inter-Process Communication) namespace</h4>
<div class="outline-text-4" id="text-2-2-5">
<p>
进程间通信涉及的IPC资源包括常见的信号量、消息队列和共享内存。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Docker 常用选项</h2>
<div class="outline-text-2" id="text-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">选项</th>
<th scope="col" class="left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-i</td>
<td class="left">交互模式，始终保持输入流开放</td>
</tr>

<tr>
<td class="left">-t</td>
<td class="left">分配一个伪终端</td>
</tr>

<tr>
<td class="left">&#x2013;name</td>
<td class="left">启动时指定容器的名字</td>
</tr>

<tr>
<td class="left">-c</td>
<td class="left">给运行在容器中的所有进程分配CPU的shares值</td>
</tr>

<tr>
<td class="left">-m</td>
<td class="left">用于限制为容器中所有进程</td>
</tr>

<tr>
<td class="left">-v</td>
<td class="left">用于挂载一个Volume，可以用多个-v参数同时挂载多个，格式：[host-dir]:[container-dir]:[rw/ro]</td>
</tr>

<tr>
<td class="left">-p</td>
<td class="left">用于将容器的端口映射到宿主机的端口，常用格式：hostPort:containerport</td>
</tr>

<tr>
<td class="left">run</td>
<td class="left">新建一个容器</td>
</tr>

<tr>
<td class="left">start/stop/restart</td>
<td class="left">操作一个已存在的容器</td>
</tr>

<tr>
<td class="left">rmi/rm</td>
<td class="left">rmi 用于删除镜像，rm用来删除容器</td>
</tr>

<tr>
<td class="left">attach</td>
<td class="left">连接到一个正在运行的容器</td>
</tr>

<tr>
<td class="left">inspect</td>
<td class="left">查看镜像和容器的详细信息，默认列出所有信息，&#x2013;format 参数用来指定输出的模板格式：docker inspect &#x2013;format='{{.NetworkSettings.IPAddress}}' ee36</td>
</tr>

<tr>
<td class="left">events、history和logs命令</td>
<td class="left">用于查看Docker的系统日志信息。events 打印实时的系统事件; history打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录; logs 打印容器中进程的运行日志</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: CarlJohn</p>
<p class="date">Created: 2016-02-23 Tue 18:17</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
