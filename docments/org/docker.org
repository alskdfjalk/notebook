* The Docker user guide
** 目的
   1. docker中运行你的应用程序
   2. 运行你自己的容器
   3. 创建docker镜像
   4. 分享docker镜像
** Docker Hub
*** 地址
    https://hub.docker.com/
** Docker 应用"Hello world"
*** 在容器中输出hello world
    #+BEGIN_SRC shell
      sudo docker run centos:6 echo 'hello world'
      hello world
    #+END_SRC
    1. 命令解释
    2. docker run 组合会运行容器
    3. centos:6 指定镜像版本（如果本地没有找到镜像，则从docker.com查找
    4. 容器中执行的命令
*** 交互式的容器
    #+BEGIN_SRC shell
      sudo docker run -t -i centos:6 /bin/bash
      root@af8bae53bdd3:/#
    #+END_SRC
    1. 选项解释：

       -t 表示在新容器内指定一个伪终端或终端

       -i 表示允许对容器内的(STDIN)进行交互
*** 容器成为守护进程
    1. 启动进程
	#+BEGIN_SRC shell
	  sudo docker run -d centos:6 bash -c "while true; do echo hello world; done"
	  1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147(容器ID（Container ID)
	#+END_SRC
    2. 容器进程查看
	#+BEGIN_SRC shell
	  sudo docker ps
	  CONTAINER ID  IMAGE         COMMAND            CREATED       STATUS     PORTS   NAMES
	  7d045853d31b centos:6 "bash -c 'while true;" 7 minutes ago  Up 7 minutes    furious_wozniak
	#+END_SRC
    3. 查看容器内应用的输出
       #+BEGIN_SRC shell
	 sudo docker logs furious_wozniak
       #+END_SRC
    4. 关闭容器
       #+BEGIN_SRC shell
	 sudo docker stop furious_wozniak
       #+END_SRC
** Docker 运行实例
*** 启动一个实例
    #+BEGIN_SRC shell
      sudo docker run -d -P training/webapp python app.py
    #+END_SRC
    -P 选项通知 Docker 将容器内部使用的网络端口映射到我们使用的主机上

    本例中指定了training/web 镜像。这个镜像已经包含了简单的Flask web 应用

*** 查看状态
     #+BEGIN_SRC shell
       $ sudo docker ps -l
       # 多出一个 0.0.0.0:32768->5000/tcp
       # 5000端口是镜像预定义的端口
       # 可以在构建容器时指定默认端口
     #+END_SRC

*** 监听在其他端口
    #+BEGIN_SRC shell
      sudo docker run -d -p 5000:5000 training/webapp python app.py
    #+END_SRC

*** 查看网络端口快捷方式
    #+BEGIN_SRC shell
      $ sudo docker port xxxxxxxxxx 5000
    #+END_SRC
*** 查看WEB应用日志
    #+BEGIN_SRC shell
      $ sudo docker logs -f nostalgic_morse
      ,* Running on http://0.0.0.0:5000/
      10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -
      10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 -
    #+END_SRC
*** 查看WEB应用的进程
    #+BEGIN_SRC shell
      $ sudo docker top xxxxxx_xxx
    #+END_SRC
*** 查看docker容器的配置和状态信息
    #+BEGIN_SRC shell
      $ sudo docker inspect xxxxxxx_xxx
    #+END_SRC

    #+BEGIN_SRC shell
      sudo docker inspect -f '{{ .NetworkSettings.IPAddress }}' nostalgic_morse
    #+END_SRC
*** 重启WEB应用容器
    #+BEGIN_SRC shell
      $ sudo docker restart xxxxxx_xxx
    #+END_SRC
*** 删除容器
    #+BEGIN_SRC shell
      $ sudo docker rm xxxxxx_xxxx
    #+END_SRC

    注意：不能删除正在运行中的容器，必须先stop
** Docker 镜像
*** 公共镜像
***** 在主机上列出镜像列表
    列出本地可以使用的镜像
    #+BEGIN_SRC shell
      $ sudo docker images
    #+END_SRC
***** 获取一个新的镜像
    #+BEGIN_SRC shell
      $ sudo docker pull centos
    #+END_SRC
***** 搜索镜像
    #+BEGIN_SRC shell
      $ sudo docker search centos
    #+END_SRC
*** 自定义镜像
***** 更新并且提交更改
     #+BEGIN_SRC shell
       $ sudo docker run -t -i training/sinatra /bin/bash
       root@0b2616b0e5a8:/#
       注意：已创建容器ID 0b2616b0e5a8，需要指定这个ID来提交新的更改
     #+END_SRC

     修改之后提交

     #+BEGIN_SRC shell
       $ sudo docker commit -m="Added json gem" -a="Kate Smith" 0b2616b0e5a8 ouruser/sinatra:v2
       4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
     #+END_SRC

     -m 参数来指定提交信息

     -a 参数来指定提交人
***** 使用 Dockerfile 构建镜像
     1. 准备路径
	#+BEGIN_SRC shell
	  $ cd /tmp
	  $ mkdir sinatra
	  $ cd sinatra
	  $ touch Dockerfile
	#+END_SRC
     2. 编写配置

	在Dockerfile添加如下内容
	#+BEGIN_SRC conf
	  # This is a comment
	  FROM fedora
	  MAINTAINER CJ <zhangyafeng097@emao.com>
	  RUN dnf install emacs -y
	#+END_SRC
     3. 执行打包（构建）
	#+BEGIN_SRC shell
	  $ sudo docker build -t lala/sinatra:v5 /tmp/sinatra
	#+END_SRC

     4. 注意

	/*与存储程序驱动无关，镜像不能超过127层。这是一种全局设置，为了是从整体上来优化镜像的大小。*/

     5. Dockerfile资料
	https://docs.docker.com/userguide/level1/
*** 镜像标签(tag)
***** 添加标签
     #+BEGIN_SRC shell
       $ docker tag 5db5f8471261 ouruser/sinatra:devel
       docker tag 需要使用镜像ID，这里是 5db5f8471261，用户名、镜像源和新的标签名。
     #+END_SRC
***** 查看某镜像的标签
     #+BEGIN_SRC shell
       $ docker images ouruser/sinatra
       REPOSITORY          TAG     IMAGE ID      CREATED        VIRTUAL SIZE
       ouruser/sinatra     latest  5db5f8471261  11 hours ago   446.7 MB
       ouruser/sinatra     devel   5db5f8471261  11 hours ago   446.7 MB
       ouruser/sinatra     v2      5db5f8471261  11 hours ago   446.7 MB
     #+END_SRC
** Docker 连接容器
*** 端口映射
    1. 指定udp映射
       #+BEGIN_SRC shell
	 $ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
       #+END_SRC
*** 容器连接
***** 概念
     端口映射并不是唯一把docker连接到另一个容器的方法。docker有一个连接系统允许将多个容器连接在一起，
     共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。
***** 容器命名
     #+BEGIN_SRC shell
       $ sudo docker run -d -P --name web training/webapp python app.py
     #+END_SRC
***** 获取容器名字
     #+BEGIN_SRC shell
       $ sudo docker inspect -f "{{ .Name }}" aed84ee21bde
       /web
     #+END_SRC
***** 容器连接
     连接允许容器之间可见并且安全地进行通信。使用--link创建连接。我们创建一个新容器，这个容器是数据库。
     1. 创建一个db容器
	#+BEGIN_SRC shell
	  $ sudo docker run -d --name db training/postgres
	#+END_SRC
     2. 创建一个web容器连接db容器
	#+BEGIN_SRC shell
	  $ sudo docker run -d -P --name web --link db:db training/webapp python app.py
	  # --link name:alias
	#+END_SRC

* 原理（实现方式）
** 目的
   了解docker的实现机制会有助于用更合适的方式来使用docker
** namespace
*** 资源隔离标志位(20多种CLONE_*)
    | namespace | 系统调用参数  | 隔离内容                   |
    |-----------+---------------+----------------------------|
    | UTS       | CLONE_NEWUTS  | 主机名与域名               |
    | IPC       | CLONE_NEWIPC  | 信号量、消息队列和共享内存 |
    | PID       | CLONE_NEWPID  | 进程编号                   |
    | Network   | CLONE_NEWNET  | 网络设备、网络栈、端口     |
    | Mount     | CLONE_NEWNS   | 挂载点                     |
    | User      | CLONE_NEWUSER | 用户和用户组                     |
*** /proc/[pid]/ns 目录
    从3.8内核开始，可以在该目录下看到指向不同namespace号的文件如：
    #+BEGIN_SRC shell
      [cj @ office 12:39 ~]$ ls -l /proc/$$/ns
      总用量 0
      lrwxrwxrwx 1 cj cj 0 2月  23 12:39 ipc -> ipc:[4026531839]
      lrwxrwxrwx 1 cj cj 0 2月  23 12:39 mnt -> mnt:[4026531840]
      lrwxrwxrwx 1 cj cj 0 2月  23 12:39 net -> net:[4026531957]
      lrwxrwxrwx 1 cj cj 0 2月  23 12:39 pid -> pid:[4026531836]
      lrwxrwxrwx 1 cj cj 0 2月  23 12:39 user -> user:[4026531837]
      lrwxrwxrwx 1 cj cj 0 2月  23 12:39 uts -> uts:[4026531838]
    #+END_SRC
*** namespace的四种API
**** clone()
    1. 通过clone()在创建新进程的同时创建namespace
       #+BEGIN_SRC c
	 int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);
	 // child_func 传入子进程运行的程序主函数
	 // child_stack 传入子进程使用的栈空间
	 // flags 表示使用哪些CLONE_*标志位，与namespace相关的已列在上表中
	 // args 用于传入用户参数
       #+END_SRC
**** setns() 加入一个已经存在的namespace
    在 Docker 中，使用 docker exec 在已经运行着的容器中执行一个新的命令，就需要用到该方法。
    #+BEGIN_SRC C
      int setns(int fd, int nstype);
      // 参数 fd 表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录的文件喵舒服。
      // 参数 nstype 让调用者可以检查mespace类型是否符合实际要求。参数为 0 时 不检查。
    #+END_SRC

    示例：
    #+BEGIN_SRC shell
      touch ~/uts
      mount --bind /proc/27514/ns/utf ~/uts
    #+END_SRC
    #+BEGIN_SRC c
      fd = open(argv[1], O_RDONLY);
      setns(fd, 0);
      execvp(argv[2], &argv[2]);
    #+END_SRC

**** unshare()
    同 clone()，但运行在原先的进程上，不需要启动一个新进程。(在Docker中并没有使用这个接口）
    #+BEGIN_SRC c
      int unshare(int flags);
    #+END_SRC

**** fork()
    就这么点事儿，fork后看返回值来确定自己是否是子进程，然后做不同的操作 - -|||

*** UTS(UNIX Time-sharing System) namespace
    提供了主机名和域名的隔离，这样才能在网络上被当作一个独立的节点，而非宿主机上的一个进程。
    在Docker中，每个镜像基本都以自身提供的服务名称来命名镜像的hostname，且不会对宿主机产生任何影响，原理就是利用UTS namespace
    #+BEGIN_SRC c
      #define _GNU_SOURCE
      #include <sys/types.h>
      #include <sys/wait.h>
      #include <stdio.h>
      #include <sched.h>
      #include <signal.h>
      #include <unistd.h>

      #define STACK_SIZE (1024 * 1024)

      static char child_stack[STACK_SIZE];
      char * const child_args[] = {
	      "/bin/bash",
	      NULL,
      };

      int child_main(void *args)
      {
	      printf("在子进程中!\n");
	      sethostname("NewNamespace", 12);
	      execv(child_args[0], child_args);
	      return 1;
      }

      int main()
      {
	      printf("程序开始：\n");
	      int child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, NULL);
	      if (0 > child_pid)
		      perror("不知到为什么错了");
	      waitpid(child_pid, NULL, 0);
	      puts("已退出");
	      return 0;
      }
    #+END_SRC

*** IPC(Inter-Process Communication) namespace
    进程间通信涉及的IPC资源包括常见的信号量、消息队列和共享内存。
* Docker 常用选项
  | 选项                      | 作用                                                                                                                                                            |
  |---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | -i                        | 交互模式，始终保持输入流开放                                                                                                                                    |
  | -t                        | 分配一个伪终端                                                                                                                                                  |
  | --name                    | 启动时指定容器的名字                                                                                                                                            |
  | -c                        | 给运行在容器中的所有进程分配CPU的shares值                                                                                                                       |
  | -m                        | 用于限制为容器中所有进程                                                                                                                                        |
  | -v                        | 用于挂载一个Volume，可以用多个-v参数同时挂载多个，格式：[host-dir]:[container-dir]:[rw/ro]                                                                      |
  | -p                        | 用于将容器的端口映射到宿主机的端口，常用格式：hostPort:containerport                                                                                            |
  | run                       | 新建一个容器                                                                                                                                                    |
  | start/stop/restart        | 操作一个已存在的容器                                                                                                                                            |
  | rmi/rm                    | rmi 用于删除镜像，rm用来删除容器                                                                                                                                |
  | attach                    | 连接到一个正在运行的容器                                                                                                                                        |
  | inspect                   | 查看镜像和容器的详细信息，默认列出所有信息，--format 参数用来指定输出的模板格式：docker inspect --format='{{.NetworkSettings.IPAddress}}' ee36                  |
  | events、history和logs命令 | 用于查看Docker的系统日志信息。events 打印实时的系统事件; history打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录; logs 打印容器中进程的运行日志 |
  |                           |                                                                                                                                                                 |
