<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>docker</title>
<!-- 2016-02-26 Fri 22:31 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="CarlJohn" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css"
    href="/Users/cj/.emacs.d/org/css/htmlize.css"/>

<link rel="stylesheet" type="text/css"
    href="/Users/cj/.emacs.d/org/css/bigblow.css"/>

<link rel="stylesheet" type="text/css"
    href="/Users/cj/.emacs.d/org/css/hideshow.css"/>


<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery-1.11.0.min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery-ui-1.10.2.min.js"></script>


<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.localscroll-min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.scrollTo-1.4.3.1-min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.zclip.min.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/bigblow.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/hideshow.js"></script>

<script type="text/javascript"
    src="/Users/cj/.emacs.d/org/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">docker</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. The Docker user guide</a>
<ul>
<li><a href="#sec-1-1">1.1. 目的</a></li>
<li><a href="#sec-1-2">1.2. Docker Hub</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. 地址</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. Docker 应用"Hello world"</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. 在容器中输出hello world</a></li>
<li><a href="#sec-1-3-2">1.3.2. 交互式的容器</a></li>
<li><a href="#sec-1-3-3">1.3.3. 容器成为守护进程</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4. Docker 运行实例</a>
<ul>
<li><a href="#sec-1-4-1">1.4.1. 启动一个实例</a></li>
<li><a href="#sec-1-4-2">1.4.2. 查看状态</a></li>
<li><a href="#sec-1-4-3">1.4.3. 监听在其他端口</a></li>
<li><a href="#sec-1-4-4">1.4.4. 查看网络端口快捷方式</a></li>
<li><a href="#sec-1-4-5">1.4.5. 查看WEB应用日志</a></li>
<li><a href="#sec-1-4-6">1.4.6. 查看WEB应用的进程</a></li>
<li><a href="#sec-1-4-7">1.4.7. 查看docker容器的配置和状态信息</a></li>
<li><a href="#sec-1-4-8">1.4.8. 重启WEB应用容器</a></li>
<li><a href="#sec-1-4-9">1.4.9. 删除容器</a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5. Docker 镜像</a>
<ul>
<li><a href="#sec-1-5-1">1.5.1. 公共镜像</a></li>
<li><a href="#sec-1-5-2">1.5.2. 自定义镜像</a></li>
<li><a href="#sec-1-5-3">1.5.3. 镜像标签(tag)</a></li>
</ul>
</li>
<li><a href="#sec-1-6">1.6. Docker 连接容器</a>
<ul>
<li><a href="#sec-1-6-1">1.6.1. 端口映射</a></li>
<li><a href="#sec-1-6-2">1.6.2. 容器连接</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2">2. 原理(实现方式)—— namespace</a>
<ul>
<li><a href="#sec-2-1">2.1. 目的</a></li>
<li><a href="#sec-2-2">2.2. 资源隔离标志位(20多种CLONE<sub>*</sub>)</a></li>
<li><a href="#sec-2-3">2.3. /proc/[pid]/ns 目录</a></li>
<li><a href="#sec-2-4">2.4. namespace的四种API</a>
<ul>
<li><a href="#sec-2-4-1">2.4.1. clone()</a></li>
<li><a href="#sec-2-4-2">2.4.2. setns() 加入一个已经存在的namespace</a></li>
<li><a href="#sec-2-4-3">2.4.3. unshare()</a></li>
<li><a href="#sec-2-4-4">2.4.4. fork()</a></li>
</ul>
</li>
<li><a href="#sec-2-5">2.5. Docker 相关的资源隔离标志位</a>
<ul>
<li><a href="#sec-2-5-1">2.5.1. UTS(UNIX Time-sharing System) namespace</a></li>
<li><a href="#sec-2-5-2">2.5.2. IPC(Inter-Process Communication) namespace</a></li>
<li><a href="#sec-2-5-3">2.5.3. PID(Process ID) namespace</a></li>
<li><a href="#sec-2-5-4">2.5.4. (NS namespace)mount namespace</a></li>
<li><a href="#sec-2-5-5">2.5.5. network namespace 概述</a></li>
<li><a href="#sec-2-5-6">2.5.6. user namespaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">3. 原理(实现方式)—— cgroups</a>
<ul>
<li><a href="#sec-3-1">3.1. what's the cgroups</a></li>
<li><a href="#sec-3-2">3.2. 四大功能</a></li>
<li><a href="#sec-3-3">3.3. cgroups 术语表</a></li>
<li><a href="#sec-3-4">3.4. <span class="todo TODO">TODO</span> 组织结构与基本规则 这里不理解，还需要学习</a></li>
<li><a href="#sec-3-5">3.5. 子系统简介</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Docker 常用选项</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The Docker user guide</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 目的</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>docker中运行你的应用程序
</li>
<li>运行你自己的容器
</li>
<li>创建docker镜像
</li>
<li>分享docker镜像
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Docker Hub</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 地址</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
<a href="https://hub.docker.com/">https://hub.docker.com/</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Docker 应用"Hello world"</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 在容器中输出hello world</h4>
<div class="outline-text-4" id="text-1-3-1">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run centos:6 echo 'hello world'
hello world
</pre>
</div>
<ol class="org-ol">
<li>命令解释
</li>
<li>docker run 组合会运行容器
</li>
<li>centos:6 指定镜像版本（如果本地没有找到镜像，则从docker.com查找
</li>
<li>容器中执行的命令
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 交互式的容器</h4>
<div class="outline-text-4" id="text-1-3-2">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -t -i centos:6 /bin/bash
root@af8bae53bdd3:/#
</pre>
</div>
<ol class="org-ol">
<li>选项解释：

<p>
-t 表示在新容器内指定一个伪终端或终端
</p>

<p>
-i 表示允许对容器内的(STDIN)进行交互
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> 容器成为守护进程</h4>
<div class="outline-text-4" id="text-1-3-3">
<ol class="org-ol">
<li>启动进程
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -d centos:6 bash -c "while true; do echo hello world; done"
1e5535038e285177d5214659a068137486f96ee5c2e85a4ac52dc83f2ebe4147(容器ID（Container ID)
</pre>
</div>
</li>
<li>容器进程查看
<div class="org-src-container">

<pre class="src src-shell">sudo docker ps
CONTAINER ID  IMAGE         COMMAND            CREATED       STATUS     PORTS   NAMES
7d045853d31b centos:6 "bash -c 'while true;" 7 minutes ago  Up 7 minutes    furious_wozniak
</pre>
</div>
</li>
<li>查看容器内应用的输出
<div class="org-src-container">

<pre class="src src-shell">sudo docker logs furious_wozniak
</pre>
</div>
</li>
<li>关闭容器
<div class="org-src-container">

<pre class="src src-shell">sudo docker stop furious_wozniak
</pre>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Docker 运行实例</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> 启动一个实例</h4>
<div class="outline-text-4" id="text-1-4-1">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -d -P training/webapp python app.py
</pre>
</div>
<p>
-P 选项通知 Docker 将容器内部使用的网络端口映射到我们使用的主机上
</p>

<p>
本例中指定了training/web 镜像。这个镜像已经包含了简单的Flask web 应用
</p>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> 查看状态</h4>
<div class="outline-text-4" id="text-1-4-2">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker ps -l
# 多出一个 0.0.0.0:32768-&gt;5000/tcp
# 5000端口是镜像预定义的端口
# 可以在构建容器时指定默认端口
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> 监听在其他端口</h4>
<div class="outline-text-4" id="text-1-4-3">
<div class="org-src-container">

<pre class="src src-shell">sudo docker run -d -p 5000:5000 training/webapp python app.py
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4"><span class="section-number-4">1.4.4</span> 查看网络端口快捷方式</h4>
<div class="outline-text-4" id="text-1-4-4">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker port xxxxxxxxxx 5000
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5"><span class="section-number-4">1.4.5</span> 查看WEB应用日志</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker logs -f nostalgic_morse
* Running on http://0.0.0.0:5000/
10.0.2.2 - - [23/May/2014 20:16:31] "GET / HTTP/1.1" 200 -
10.0.2.2 - - [23/May/2014 20:16:31] "GET /favicon.ico HTTP/1.1" 404 -
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-6" class="outline-4">
<h4 id="sec-1-4-6"><span class="section-number-4">1.4.6</span> 查看WEB应用的进程</h4>
<div class="outline-text-4" id="text-1-4-6">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker top xxxxxx_xxx
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-7" class="outline-4">
<h4 id="sec-1-4-7"><span class="section-number-4">1.4.7</span> 查看docker容器的配置和状态信息</h4>
<div class="outline-text-4" id="text-1-4-7">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker inspect xxxxxxx_xxx
</pre>
</div>

<div class="org-src-container">

<pre class="src src-shell">sudo docker inspect -f '{{ .NetworkSettings.IPAddress }}' nostalgic_morse
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-8" class="outline-4">
<h4 id="sec-1-4-8"><span class="section-number-4">1.4.8</span> 重启WEB应用容器</h4>
<div class="outline-text-4" id="text-1-4-8">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker restart xxxxxx_xxx
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-4-9" class="outline-4">
<h4 id="sec-1-4-9"><span class="section-number-4">1.4.9</span> 删除容器</h4>
<div class="outline-text-4" id="text-1-4-9">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker rm xxxxxx_xxxx
</pre>
</div>

<p>
注意：不能删除正在运行中的容器，必须先stop
</p>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Docker 镜像</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1"><span class="section-number-4">1.5.1</span> 公共镜像</h4>
<div class="outline-text-4" id="text-1-5-1">
</div><ol class="org-ol"><li><a id="sec-1-5-1-0-1" name="sec-1-5-1-0-1"></a>在主机上列出镜像列表<br  /><div class="outline-text-6" id="text-1-5-1-0-1">
<p>
列出本地可以使用的镜像
</p>
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker images
</pre>
</div>
</div>
</li>
<li><a id="sec-1-5-1-0-2" name="sec-1-5-1-0-2"></a>获取一个新的镜像<br  /><div class="outline-text-6" id="text-1-5-1-0-2">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker pull centos
</pre>
</div>
</div>
</li>
<li><a id="sec-1-5-1-0-3" name="sec-1-5-1-0-3"></a>搜索镜像<br  /><div class="outline-text-6" id="text-1-5-1-0-3">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker search centos
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2"><span class="section-number-4">1.5.2</span> 自定义镜像</h4>
<div class="outline-text-4" id="text-1-5-2">
</div><ol class="org-ol"><li><a id="sec-1-5-2-0-1" name="sec-1-5-2-0-1"></a>更新并且提交更改<br  /><div class="outline-text-6" id="text-1-5-2-0-1">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -t -i training/sinatra /bin/bash
root@0b2616b0e5a8:/#
注意：已创建容器ID 0b2616b0e5a8，需要指定这个ID来提交新的更改
</pre>
</div>

<p>
修改之后提交
</p>

<div class="org-src-container">

<pre class="src src-shell">$ sudo docker commit -m="Added json gem" -a="Kate Smith" 0b2616b0e5a8 ouruser/sinatra:v2
4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c
</pre>
</div>

<p>
-m 参数来指定提交信息
</p>

<p>
-a 参数来指定提交人
</p>
</div>
</li>
<li><a id="sec-1-5-2-0-2" name="sec-1-5-2-0-2"></a>使用 Dockerfile 构建镜像<br  /><div class="outline-text-6" id="text-1-5-2-0-2">
<ol class="org-ol">
<li>准备路径
<div class="org-src-container">

<pre class="src src-shell">$ cd /tmp
$ mkdir sinatra
$ cd sinatra
$ touch Dockerfile
</pre>
</div>
</li>
<li>编写配置

<p>
在Dockerfile添加如下内容
</p>
<div class="org-src-container">

<pre class="src src-conf"># This is a comment
FROM fedora
MAINTAINER CJ &lt;zhangyafeng097@emao.com&gt;
RUN dnf install emacs -y
</pre>
</div>
</li>
<li>执行打包（构建）
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker build -t lala/sinatra:v5 /tmp/sinatra
</pre>
</div>
</li>

<li>注意

<p>
<i><b>与存储程序驱动无关，镜像不能超过127层。这是一种全局设置，为了是从整体上来优化镜像的大小。</b></i>
</p>
</li>

<li>Dockerfile资料
<a href="https://docs.docker.com/userguide/level1/">https://docs.docker.com/userguide/level1/</a>
</li>
</ol>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3"><span class="section-number-4">1.5.3</span> 镜像标签(tag)</h4>
<div class="outline-text-4" id="text-1-5-3">
</div><ol class="org-ol"><li><a id="sec-1-5-3-0-1" name="sec-1-5-3-0-1"></a>添加标签<br  /><div class="outline-text-6" id="text-1-5-3-0-1">
<div class="org-src-container">

<pre class="src src-shell">$ docker tag 5db5f8471261 ouruser/sinatra:devel
docker tag 需要使用镜像ID，这里是 5db5f8471261，用户名、镜像源和新的标签名。
</pre>
</div>
</div>
</li>
<li><a id="sec-1-5-3-0-2" name="sec-1-5-3-0-2"></a>查看某镜像的标签<br  /><div class="outline-text-6" id="text-1-5-3-0-2">
<div class="org-src-container">

<pre class="src src-shell">$ docker images ouruser/sinatra
REPOSITORY          TAG     IMAGE ID      CREATED        VIRTUAL SIZE
ouruser/sinatra     latest  5db5f8471261  11 hours ago   446.7 MB
ouruser/sinatra     devel   5db5f8471261  11 hours ago   446.7 MB
ouruser/sinatra     v2      5db5f8471261  11 hours ago   446.7 MB
</pre>
</div>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Docker 连接容器</h3>
<div class="outline-text-3" id="text-1-6">
</div><div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1"><span class="section-number-4">1.6.1</span> 端口映射</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li>指定udp映射
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2"><span class="section-number-4">1.6.2</span> 容器连接</h4>
<div class="outline-text-4" id="text-1-6-2">
</div><ol class="org-ol"><li><a id="sec-1-6-2-0-1" name="sec-1-6-2-0-1"></a>概念<br  /><div class="outline-text-6" id="text-1-6-2-0-1">
<p>
端口映射并不是唯一把docker连接到另一个容器的方法。docker有一个连接系统允许将多个容器连接在一起，
共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。
</p>
</div>
</li>
<li><a id="sec-1-6-2-0-2" name="sec-1-6-2-0-2"></a>容器命名<br  /><div class="outline-text-6" id="text-1-6-2-0-2">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d -P --name web training/webapp python app.py
</pre>
</div>
</div>
</li>
<li><a id="sec-1-6-2-0-3" name="sec-1-6-2-0-3"></a>获取容器名字<br  /><div class="outline-text-6" id="text-1-6-2-0-3">
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker inspect -f "{{ .Name }}" aed84ee21bde
/web
</pre>
</div>
</div>
</li>
<li><a id="sec-1-6-2-0-4" name="sec-1-6-2-0-4"></a>容器连接<br  /><div class="outline-text-6" id="text-1-6-2-0-4">
<p>
连接允许容器之间可见并且安全地进行通信。使用&#x2013;link创建连接。我们创建一个新容器，这个容器是数据库。
</p>
<ol class="org-ol">
<li>创建一个db容器
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d --name db training/postgres
</pre>
</div>
</li>
<li>创建一个web容器连接db容器
<div class="org-src-container">

<pre class="src src-shell">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py
# --link name:alias
</pre>
</div>
</li>
</ol>
</div>
</li></ol>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 原理(实现方式)—— namespace</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 目的</h3>
<div class="outline-text-3" id="text-2-1">
<p>
了解docker的实现机制会有助于用更合适的方式来使用docker
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 资源隔离标志位(20多种CLONE<sub>*</sub>)</h3>
<div class="outline-text-3" id="text-2-2">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">namespace</th>
<th scope="col" class="left">系统调用参数</th>
<th scope="col" class="left">隔离内容</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">UTS</td>
<td class="left">CLONE<sub>NEWUTS</sub></td>
<td class="left">主机名与域名</td>
</tr>

<tr>
<td class="left">IPC</td>
<td class="left">CLONE<sub>NEWIPC</sub></td>
<td class="left">信号量、消息队列和共享内存</td>
</tr>

<tr>
<td class="left">PID</td>
<td class="left">CLONE<sub>NEWPID</sub></td>
<td class="left">进程编号</td>
</tr>

<tr>
<td class="left">Network</td>
<td class="left">CLONE<sub>NEWNET</sub></td>
<td class="left">网络设备、网络栈、端口</td>
</tr>

<tr>
<td class="left">Mount</td>
<td class="left">CLONE<sub>NEWNS</sub></td>
<td class="left">挂载点</td>
</tr>

<tr>
<td class="left">User</td>
<td class="left">CLONE<sub>NEWUSER</sub></td>
<td class="left">用户和用户组</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> /proc/[pid]/ns 目录</h3>
<div class="outline-text-3" id="text-2-3">
<p>
从3.8内核开始，可以在该目录下看到指向不同namespace号的文件如：
</p>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 12:39 ~]$ ls -l /proc/$$/ns
总用量 0
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 ipc -&gt; ipc:[4026531839]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 mnt -&gt; mnt:[4026531840]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 net -&gt; net:[4026531957]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 pid -&gt; pid:[4026531836]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 user -&gt; user:[4026531837]
lrwxrwxrwx 1 cj cj 0 2月  23 12:39 uts -&gt; uts:[4026531838]
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> namespace的四种API</h3>
<div class="outline-text-3" id="text-2-4">
</div><div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1"><span class="section-number-4">2.4.1</span> clone()</h4>
<div class="outline-text-4" id="text-2-4-1">
<ol class="org-ol">
<li>通过clone()在创建新进程的同时创建namespace
<div class="org-src-container">

<pre class="src src-c">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);
// child_func 传入子进程运行的程序主函数
// child_stack 传入子进程使用的栈空间
// flags 表示使用哪些CLONE_*标志位，与namespace相关的已列在上表中
// args 用于传入用户参数
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2"><span class="section-number-4">2.4.2</span> setns() 加入一个已经存在的namespace</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
在 Docker 中，使用 docker exec 在已经运行着的容器中执行一个新的命令，就需要用到该方法。
</p>
<div class="org-src-container">

<pre class="src src-C">int setns(int fd, int nstype);
// 参数 fd 表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录的文件喵舒服。
// 参数 nstype 让调用者可以检查mespace类型是否符合实际要求。参数为 0 时 不检查。
</pre>
</div>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-shell">touch ~/uts
mount --bind /proc/27514/ns/utf ~/uts
</pre>
</div>
<div class="org-src-container">

<pre class="src src-c">fd = open(argv[1], O_RDONLY);
setns(fd, 0);
execvp(argv[2], &amp;argv[2]);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3"><span class="section-number-4">2.4.3</span> unshare()</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
同 clone()，但运行在原先的进程上，不需要启动一个新进程。(在Docker中并没有使用这个接口）
</p>
<div class="org-src-container">

<pre class="src src-c">int unshare(int flags);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4"><span class="section-number-4">2.4.4</span> fork()</h4>
<div class="outline-text-4" id="text-2-4-4">
<p>
就这么点事儿，fork后看返回值来确定自己是否是子进程，然后做不同的操作 - -|||
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Docker 相关的资源隔离标志位</h3>
<div class="outline-text-3" id="text-2-5">
</div><div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1"><span class="section-number-4">2.5.1</span> UTS(UNIX Time-sharing System) namespace</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
提供了主机名和域名的隔离，这样才能在网络上被当作一个独立的节点，而非宿主机上的一个进程。
在Docker中，每个镜像基本都以自身提供的服务名称来命名镜像的hostname，且不会对宿主机产生任何影响，原理就是利用UTS namespace
</p>
<div class="org-src-container">

<pre class="src src-c">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];
char * const child_args[] = {
	"/bin/bash",
	NULL,
};

int child_main(void *args)
{
	printf("在子进程中!\n");
	sethostname("NewNamespace", 12);
	execv(child_args[0], child_args);
	return 1;
}

int main()
{
	printf("程序开始：\n");
	int child_pid = clone(child_main, child_stack + STACK_SIZE,
			      CLONE_NEWUTS | SIGCHLD, NULL);
	if (0 &gt; child_pid)
		perror("不知到为什么错了");
	waitpid(child_pid, NULL, 0);
	puts("已退出");
	return 0;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5-2" class="outline-4">
<h4 id="sec-2-5-2"><span class="section-number-4">2.5.2</span> IPC(Inter-Process Communication) namespace</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
进程间通信涉及的IPC资源包括常见的信号量、消息队列和共享内存。
申请IPC资源就申请了一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。
在同一个IPC namespace下的进程彼此可见，不同IPC namespace下的进程则互相不可见。
</p>

<div class="org-src-container">

<pre class="src src-shell">$ ipcmk -Q    # 创建一个message queue
$ ipcs -q     # 查看已经开启的 message queue
</pre>
</div>
<div class="org-src-container">

<pre class="src src-c">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;

#define STACK_SIZE (1024 * 1024)

static char child_stack[STACK_SIZE];
char * const child_args[] = {
 "/bin/bash",
 NULL,
};

int child_main(void *args)
{
 printf("在子进程中!\n");
 sethostname("NewNamespace", 12);
 execv(child_args[0], child_args);
 return 1;
}

int main()
{
 printf("程序开始：\n");
 int child_pid = clone(child_main, child_stack + STACK_SIZE,
		       CLONE_NEWIPC | SIGCHLD | CLONE_NEWUTS, NULL);
 if (0 &gt; child_pid)
	 perror("不知到为什么错了");
 waitpid(child_pid, NULL, 0);
 puts("已退出");
 return 0;
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-shell">$ ipcs -q    # 查看已经开启的消息队列时已经看不到刚才创建的了, 实现了IPC的隔离。
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5-3" class="outline-4">
<h4 id="sec-2-5-3"><span class="section-number-4">2.5.3</span> PID(Process ID) namespace</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
隔离PID
</p>
<ol class="org-ol">
<li>每个PID namespace中的第一个进程“PID 1”，都会像传统Linux中的init进程一样拥有特权，起特殊作用。
</li>
<li>一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其它节点的PID在这个namespace中没有任何意义
</li>
<li>如果在新的PID namespace中重新挂载/proc文件系统，会发现其下只显示同一个PID namespace中的其它进程。
</li>
<li>在root namespace中可以看到所有进程，并且递归包含所有子节点中的进程。
</li>
</ol>

<p>
扩展：
    外部监控Docker中运行的程序，监控Dockerdaemon所在的PID namespace下的所有进程机器子进程，如有需要，可以筛选检查。
</p>

<p>
将上例中的代码修改如下：
</p>
<div class="org-src-container">

<pre class="src src-c">// [...]
int child_pid = clone(child_main, child_stack + STAK_SIZE,
		      CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS, | SIGHLD, NULL);
// [...]
</pre>
</div>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 17:08 ~/tmp]$ sudo ./a.out
程序开始：
在子进程中!
[root @ NewNamespace 17:08 /home/cj/tmp]$ echo $$
1
[root @ NewNamespace 17:08 /home/cj/tmp]$ ps aux | grep a.out
root     16032  0.0  0.0 233532  7336 pts/0    S    17:08   0:00 sudo ./a.out
root     16033  0.0  0.0   5192   788 pts/0    S    17:08   0:00 ./a.out
root     16213  0.0  0.0 114344  2352 pts/0    S+   17:08   0:00 grep --color=auto a.out
[root @ NewNamespace 17:08 /home/cj/tmp]$ exit
已退出
[cj @ office 17:08 ~/tmp]$ echo $$
13636
[cj @ office 17:08 ~/tmp]$
</pre>
</div>

<p>
<i><b>但是，由于尚未对文件系统挂载点隔离，所以/proc目录还是可以读取到当前宿主机的所有进程状态</b></i>
</p>
</div>

<ol class="org-ol"><li><a id="sec-2-5-3-1" name="sec-2-5-3-1"></a>PID namespace 中的 init 进程<br  /><div class="outline-text-5" id="text-2-5-3-1">
<ol class="org-ol">
<li>容器中需要一个类似宿主机的 init 进程来维护容器中的进程表
</li>
<li>如果确实需要在一个Docker容器中运行多个进程，最先启动的命令进程应该是具有资源监控与回收等管理能力的，如 bash。
</li>
</ol>
</div>
</li>
<li><a id="sec-2-5-3-2" name="sec-2-5-3-2"></a>信号与 init 进程<br  /><div class="outline-text-5" id="text-2-5-3-2">
<ol class="org-ol">
<li>init 进程的特权 —— 信号屏蔽
如果 init 中没有编写处理某个信号的代码逻辑，那么与 init 在同一个 PID namespace 下的进程（即使有超级权限）
发送给 init 的信号都会被屏蔽。（主要作用是防止 init 进程被误杀）
</li>
<li>父节点发送给子节点的 SIGKILL 和 SIGSTOP，子节点的 init 会强制执行。(父节点可以终止子节点的进程）
</li>
<li>init 被销毁后，同一 namespace(PID) 中的其它进程也会接收到 SIGKILL。
理论上，该 PID namespace 将不存在，除非 /proc/[pid]/ns/pid 处于被挂载或者打开的状态，namespace就会
保留，但是也不能执行 setns() 、fork()，所以实际上也没有用了。
</li>
</ol>
</div>
</li>
<li><a id="sec-2-5-3-3" name="sec-2-5-3-3"></a>挂载 proc 文件系统<br  /><div class="outline-text-5" id="text-2-5-3-3">
<p>
如果需要只能看到 PID namespace 本身应该看到的进程，需要重新挂载 /proc：
</p>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 18:08 ~/tmp]$ sudo ./a.out
程序开始：
在子进程中!
[root @ NewNamespace 18:08 /home/cj/tmp]$ mount -t proc proc /proc
[root @ NewNamespace 18:08 /home/cj/tmp]$ ps auxf
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.3  0.0 118372  4872 pts/0    S    18:08   0:00 /bin/bash
root        44  0.0  0.0 153184  3952 pts/0    R+   18:08   0:00 ps auxf
[root @ NewNamespace 18:08 /home/cj/tmp]$ umount /proc
[root @ NewNamespace 18:08 /home/cj/tmp]$ exit
</pre>
</div>
</div>
</li>
<li><a id="sec-2-5-3-4" name="sec-2-5-3-4"></a>unshare() 和 setns()<br  /><div class="outline-text-5" id="text-2-5-3-4">
<p>
<i><b>创建其它 namespace 时这两个调用都会直接进入新的namespace，PID namespace则不会</b></i>
</p>

<p>
<i><b>一旦程序进程创建之后，它的 PID namespace 的关系就确定下来了，进程不会变更它们对应的 PID namespace。</b></i>
<i><b>在Docker中，docker exec 会使用setns()函数加入已经存在的命名空间，但是最终还是会调用clone()函数。</b></i>
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-5-4" class="outline-4">
<h4 id="sec-2-5-4"><span class="section-number-4">2.5.4</span> (NS namespace)mount namespace</h4>
<div class="outline-text-4" id="text-2-5-4">
<ol class="org-ol">
<li>历史上第一个Linux namespace
</li>
<li>通过隔离文件系统挂载点对隔离文件系统提供支持
</li>
<li>标识符： CLONE<sub>NEWNS</sub>
</li>
<li>06年引入的挂载传播
<ol class="org-ol">
<li>共享关系(share relationship)
如果两个挂载对象具有共享关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之亦然。
</li>
<li>从属关系(slave relationship)
如果两个挂载对象形成从属关系，那么一个挂载对象中的挂载事件会传播到另一个挂载对象，反之不行；
在这种关系中，从属对象是事件的接受者。
</li>
</ol>
</li>
<li>一个挂载状态可能为以下一种：
<ol class="org-ol">
<li>共享挂载(shared)
传播事件的挂载对象称为共享挂载
</li>
<li>从属挂载(slave)
接收传播事件的挂载对象称为从属挂载
</li>
<li>共享／从属挂载(shared and slave)
同时兼有前述两者特征的挂载对象称为 <i><b>共享/从属挂载</b></i>
</li>
<li>私有挂载(private)
既不传播也不接收传播事件的挂载对象称为私有挂载
</li>
<li>不可绑定挂载(unbindable)
与私有挂载相似，但是不允许执行绑定挂载，即创建 mount namespace 时这块文件对象不可被复制。
</li>
</ol>
<p>
<img src="../img/docker_mount.jpg" alt="docker_mount.jpg" width="400pt" />
上图中，
</p>

<p>
最上层的 mount namespace 下的 /bin 目录与 child namespace 通过 master slave 方式
进行挂载传播，当 mount namespace 中的 /bin 目录发生变化时，发生的挂载事件能够自动传播
到 child namespace 中
</p>

<p>
/lib 目录使用完全的共享挂载传播，各 namespace 之间发生的变化都会互相影响
</p>

<p>
/proc 目录使用私有挂载传播的方式，各 mount namespace 之间互相隔离
</p>

<p>
最后的 /root 目录一半都是管理员所有，不能让其它 mount namespace 挂载绑定
</p>
</li>

<li>挂载属性命令, 默认情况下，所有挂载状态都是私有的，
<ol class="org-ol">
<li>设置为共享挂载的命令如下
<div class="org-src-container">

<pre class="src src-shell">$ mount --make-shared &lt;mount-object&gt;
</pre>
</div>
</li>
<li>从属挂载
<div class="org-src-container">

<pre class="src src-shell">$ mount --make-slave &lt;shared-mount-object&gt;
</pre>
</div>
</li>
<li>共享／从属挂载
<div class="org-src-container">

<pre class="src src-shell">$ mount --make-shared &lt;slave-mount-object&gt;
</pre>
</div>
</li>
<li>私有挂载
<div class="org-src-container">

<pre class="src src-shell">$ mount --make-private &lt;mount-object&gt;
</pre>
</div>
</li>
<li>不可绑定的挂载
<div class="org-src-container">

<pre class="src src-shell">$ make --make-unbindable &lt;mount-object&gt;
</pre>
</div>
</li>
</ol>
</li>
<li>示例
<div class="org-src-container">

<pre class="src src-c">// [...]
int child_pid = clone(child_main, child_stack + STACK_SIZE,
		      CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC,
		      CLONE_NEWUTS | SIGCHLD, NULL);
// [...]
</pre>
</div>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 21:56 ~/tmp]$ sudo mount --make-private /proc
[cj @ office 21:56 ~/tmp]$ sudo ./a.out
程序开始：
在子进程中!
[root @ NewNamespace 21:57 /home/cj/tmp]$ mount --make-private -t proc proc /proc
[root @ NewNamespace 21:57 /home/cj/tmp]$ ps auxf
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.3  0.0 118372  4836 pts/0    S    21:57   0:00 /bin/bash
root        44  0.0  0.0 153184  3740 pts/0    R+   21:57   0:00 ps auxf
[root @ NewNamespace 21:57 /home/cj/tmp]$ exit
已退出
[cj @ office 21:57 ~/tmp]$ ps aux | wc -l
184
[cj @ office 21:57 ~/tmp]$
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5-5" class="outline-4">
<h4 id="sec-2-5-5"><span class="section-number-4">2.5.5</span> network namespace 概述</h4>
<div class="outline-text-4" id="text-2-5-5">
<ol class="org-ol">
<li>一个物理的网络设备最多存在于一个network namespace中，可以通过创建veth pair(虚拟网络设备对:
有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然)在不同 network namespace 间创建通道，
以达到通信目的。
</li>
<li>在建立起 veth pair 之前，假设容器初始化的进程称为 init。Docker daemon 在宿主机上负责创建这个
veth pair，把另一端绑定到 docker0 网桥上，另一端介入新建的 network namespace 进程中。这个过程
执行期间，Docker daemon 和 init 就通过 pipe 进行通信。具体来说，就是在 Docker daemon 完成
veth pair 的创建之前，init在管道的另一端循环等待，知道管道另一端传来 Docker daemon 关于 veth
设备的信息，并关闭管道。init 才结束等待的过程，并把它的 "eth0" 启动起来。如图：

<div class="figure">
<p><img src="../img/docker_network_veth.png" alt="docker_network_veth.png" width="400pt" />
</p>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5-6" class="outline-4">
<h4 id="sec-2-5-6"><span class="section-number-4">2.5.6</span> user namespaces</h4>
<div class="outline-text-4" id="text-2-5-6">
<ol class="org-ol">
<li>隔离用户:
在宿主机上以普通用户创建的容器中，该用户可以拥有最高权限。
</li>
<li>目前6个 namespace 中最后一个支持的，3.8内核时还尚未实现所有功能。(尚不成熟)
</li>
<li>示例：
<div class="org-src-container">

<pre class="src src-c">#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sched.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/capability.h&gt;

#define STACK_SIZE (1024 * 1024)

extern cap_t cap_get_proc(void);

static char child_stack[STACK_SIZE];
char * const child_args[] = {
	"/bin/bash",
	NULL,
};

int child_main(void *args)
{
	printf("在子进程中!\n");

	cap_t caps;

	printf("eUID = %ld; eGID = %ld; ",
	       (long)geteuid(), (long)getegid());
	caps = cap_get_proc();

	printf("capabilities: %s\n", cap_to_text(caps, NULL));

	execv(child_args[0], child_args);
	return 1;
}

int main(void)
{
	printf("程序开始：\n");
	int child_pid = clone(child_main, child_stack + STACK_SIZE,
			      CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD |
			      CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER,
			      NULL);
	if (0 &gt; child_pid)
		perror("不知到为什么错了");
	waitpid(child_pid, NULL, 0);
	puts("已退出");
	return 0;
}
</pre>
</div>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 22:59 ~/tmp]$ id
uid=1000(cj) gid=1000(cj) 组=1000(cj),10(wheel)
[cj @ office 22:59 ~/tmp]$ ./a.out
程序开始：
在子进程中!
eUID = 65534; eGID = 65534; capabilities: = cap_chown,cap_dac_override,[...]37+ep
# 这时拥有了对整个文件系统做任何修改的权限
AC available
[nfsnobody @ office 22:59 ~/tmp]$ id
uid=65534(nfsnobody) gid=65534(nfsnobody) 组=65534(nfsnobody)
[nfsnobody @ office 23:00 ~/tmp]$
</pre>
</div>
</li>
<li>通过上述示例得出：
<ol class="org-ol">
<li>user namespace 创建后，第一个进程被赋予了该 namespace 中的全部权限，
这样该 init 进程就可以完成所有必要的初始化工作。
</li>
<li>从 namespace 内部观察到的 UID 和 GID 已经与外部不同了，默认显示为65534，表示尚未
与外部 namespace 用户映射。所以 <i><b>需要对 user namespace 内部的这个初始 user 和它外部 namespace 的某个用户建立映射。</b></i>
这样在操作外部 namespace 时，系统可以检验权限。
</li>
<li>新用户在新 namespace 中有全部权限，外部 namespace 用户则没有任何权限。
<div class="org-src-container">

<pre class="src src-shell">[nfsnobody @ office 23:10 ~/tmp]$ ll
总用量 28
---------- 1 nfsnobody nfsnobody 10536 2月  24 22:59 a.out
-rw-rw-r-- 1 nfsnobody nfsnobody   313 2月  22 15:07 monitor_db_m.sh
drwxrwxr-x 2 nfsnobody nfsnobody  4096 2月  18 17:12 sinatra/
-rwxr--r-- 1 nfsnobody nfsnobody   964 2月  24 22:59 uts.c*
-rwxr--r-- 1 nfsnobody nfsnobody   744 2月  24 21:43 uts.c~*
[nfsnobody @ office 23:10 /tmp]$ exit
已退出
[cj @ office 23:17 ~/tmp]$ ll
总用量 28
---------- 1 cj cj 10536 2月  24 22:59 a.out
-rw-rw-r-- 1 cj cj   313 2月  22 15:07 monitor_db_m.sh
drwxrwxr-x 2 cj cj  4096 2月  18 17:12 sinatra/
-rwxr--r-- 1 cj cj   964 2月  24 22:59 uts.c*
-rwxr--r-- 1 cj cj   744 2月  24 21:43 uts.c~*
</pre>
</div>
</li>
<li>用户绑定
两个文件:
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 15:11 ~/tmp]$ # 格式: ID-inside-ns ID-outside-ns length
[cj @ office 15:13 ~/tmp]$ cat /proc/$$/uid_map
	 0          0 4294967295
[cj @ office 11:20 ~/tmp]$ cat /proc/$$/gid_map
	 0          0 4294967295
</pre>
</div>
<p>
文件属性：
</p>
<ol class="org-ol">
<li>只允许由拥有该 user namespace 中 CAP<sub>SETUID</sub> 的父 namespace 或者子 namespace
</li>
<li>写入的进程必须是该 user namespace 的 父namespace 或者 子namespace
</li>
<li>ID-inside-ns 表示新建的 user namespace 中对应的 user/group ID，第二个字段
ID-outside-ns 表示 namespace 外部映射的 user/group ID。最后一个字段表示映射范围，
通常填1，表示只映射一个; 如果大于1的值，则按顺序建立一一映射。
</li>

<li>示例：
<div class="org-src-container">

<pre class="src src-c">// [...]
void set_uid_map(pid_t pid, int inside_id, int outside_id, int length)
{
	char path[256];
	sprintf(path, "/proc/%d/uid_map", getpid());
	FILE *uid_map = fopen(path, "w");
	if (uid_map &lt;= 0)
		perror("fopen path");
	fprintf(uid_map, "%d %d %d", inside_id, outside_id, length);
	fclose(uid_map);
}

void set_gid_map(pid_t pid, int inside_id, int outside_id, int length)
{
	char path[256];
	sprintf(path, "/proc/%d/gid_map", getpid());
	FILE *gid_map = fopen(path, "w");
	fprintf(gid_map, "%d %d %d", inside_id, outside_id, length);
	fclose(gid_map);
}
int child_main(void *args)
{
	cap_t caps;

	printf("在子进程中!\n");

	set_uid_map(getpid(), 0, 1000, 1);
	set_gid_map(getpid(), 0, 1000, 1);

	printf("eUID = %ld; eGID = %ld; ",
	       (long)geteuid(), (long)getegid());
	caps = cap_get_proc();

	printf("capabilities: %s\n", cap_to_text(caps, NULL));

	execv(child_args[0], child_args);
	return 1;
}
// [...]
</pre>
</div>
<p>
编译 &amp; 运行
</p>
<div class="org-src-container">

<pre class="src src-shell">[cj @ office 12:41 ~/tmp]$ ./a.out
程序开始：
在子进程中!
/proc/31716/uid_map
eUID = 0; eGID = 65534; ...,37+ep
AC available
[root @ office 12:41 ~/tmp]$
</pre>
</div>
</li>
</ol>
</li>
</ol>
</li>
<li>如果要把 user namespace 与其它 namespace 混合使用，依旧需要root权限。解决方案是先以普通
用户身份创建 user namespace，然后在新建的 namespace 中作为 root，再 clone() 进程加入其它
类型的 namespace 隔离。
</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 原理(实现方式)—— cgroups</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> what's the cgroups</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>由来
cgroups 最初名为 process container，Google 内两个工程师在 06 年提出，后来由于名字有歧义，
在 07 年更名为 control groups，并整合进 Linux 内核。
</li>
<li>官方定义
<i><b>cgroups 是 Linux 内核提供的一种机制，这种机制可以根据需求把一系列系统任务及其子任务整合(或</b></i>
<i><b>分离)到按资源划分等级的不同组内，从而为系统资源管理提供一个同一的框架。</b></i>
</li>
<li>特点
<ol class="org-ol">
<li>cgroups 的 API 以一个伪文件系统的方式实现，用户态的程序可以通过文件操作实现 cgroups 的组织管理。
</li>
<li>cgroups 的组织管理操作单元可以细粒度到线程级别，用户可以对其创建、销毁，实现资源再分配和管理。
</li>
<li>所有资源管理的功能都以子系统的方式实现，接口统一。
</li>
<li>子任务创建之初与其父任务处于同一个 cgroups 的控制组。
</li>
</ol>
</li>
<li>从本质上来说，cgroups 是内核附加在程序上的一系列钩子(hooks)，通过程序运行时对资源的调度触发相应的钩子
以达到资源追踪和限制的目的。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 四大功能</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li>资源限制
cgroups可以对任务使用的资源总额进行限制。如设定应用运行时使用内存的上限，一旦超过配额就发出 OOM (Out of Memory)
</li>
<li>优先级分配
通过分配的 CPU 时间片数量及磁盘 IO 带宽大小，实际上就相当于控制了任务运行的优先级。
</li>
<li>资源统计
cgroups 可以统计系统的资源使用量，如 CPU 使用时长、内存用量等，这个功能非常适用于计费。
</li>
<li>任务控制
cgroups 可以对任务执行挂起、恢复等
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> cgroups 术语表</h3>
<div class="outline-text-3" id="text-3-3">
<ol class="org-ol">
<li>task（任务）
在 cgroups 术语中，任务表示系统的一个进程或线程
</li>
<li>cgroup（控制组）
cgroups中的资源控制都以 cgroup 为单位实现。一个任务可以加入某个 cgroup，也可以从某个 cgroup
 迁移到另一个 cgroup。
</li>
<li>subsystem（子系统）
cgroups 中的子系统就是一个资源调度控制器。CPU 子系统、内存子系统各自负责自己的调度。
</li>
<li>hierarchy（层级）
层级由一系列 cgroup 以一个树状结构排列而成，每个层级通过绑定对应的子系统进行资源控制。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> <span class="todo TODO">TODO</span> 组织结构与基本规则 这里不理解，还需要学习</h3>
<div class="outline-text-3" id="text-3-4">
<ol class="org-ol">
<li>同一个层级可以附加一个或多个子系统。
</li>
<li>一个子系统可以附加到多个层级，当且仅当目标层级只有唯一一个子系统时。
</li>
<li>系统每次新建一个层级时，该系统上的所有任务默认加入这个新建层级的初始化cgroups，这个 cgroup 也被称为 root cgroup。
</li>
<li>任务在fork/clone自身时创建的子任务默认与原任务在同一个 cgroup 中，但是子任务允许被移动到不同的 cgroup 中。
</li>
</ol>


<div class="figure">
<p><img src="../img/cgroups_system.png" alt="cgroups_system.png" width="500pt" />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 子系统简介</h3>
<div class="outline-text-3" id="text-3-5">
<p>
子系统实际上就是 cgroups 的资源控制系统
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Docker 常用选项</h2>
<div class="outline-text-2" id="text-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">选项</th>
<th scope="col" class="left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">-i</td>
<td class="left">交互模式，始终保持输入流开放</td>
</tr>

<tr>
<td class="left">-t</td>
<td class="left">分配一个伪终端</td>
</tr>

<tr>
<td class="left">&#x2013;name</td>
<td class="left">启动时指定容器的名字</td>
</tr>

<tr>
<td class="left">-c</td>
<td class="left">给运行在容器中的所有进程分配CPU的shares值</td>
</tr>

<tr>
<td class="left">-m</td>
<td class="left">用于限制为容器中所有进程</td>
</tr>

<tr>
<td class="left">-v</td>
<td class="left">用于挂载一个Volume，可以用多个-v参数同时挂载多个，格式：[host-dir]:[container-dir]:[rw/ro]</td>
</tr>

<tr>
<td class="left">-p</td>
<td class="left">用于将容器的端口映射到宿主机的端口，常用格式：hostPort:containerport</td>
</tr>

<tr>
<td class="left">run</td>
<td class="left">新建一个容器</td>
</tr>

<tr>
<td class="left">start/stop/restart</td>
<td class="left">操作一个已存在的容器</td>
</tr>

<tr>
<td class="left">rmi/rm</td>
<td class="left">rmi 用于删除镜像，rm用来删除容器</td>
</tr>

<tr>
<td class="left">attach</td>
<td class="left">连接到一个正在运行的容器</td>
</tr>

<tr>
<td class="left">inspect</td>
<td class="left">查看镜像和容器的详细信息，默认列出所有信息，&#x2013;format 参数用来指定输出的模板格式：docker inspect &#x2013;format='{{.NetworkSettings.IPAddress}}' ee36</td>
</tr>

<tr>
<td class="left">events、history和logs命令</td>
<td class="left">用于查看Docker的系统日志信息。events 打印实时的系统事件; history打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录; logs 打印容器中进程的运行日志</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: CarlJohn</p>
<p class="date">Created: 2016-02-26 Fri 22:31</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
